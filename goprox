#!/bin/zsh

#
# The MIT License (MIT)
#
# Copyright (c) 2021-2025 by Oliver Ratzesberger
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

__author__='Oliver Ratzesberger <https://github.com/fxstein>'
__copyright__='Copyright (C) 2021, 2022, 2023, 2024, 2025 Oliver Ratzesberger'
__license__='MIT'
__version__='00.53.dev'
__github__='https://github.com/fxstein/GoProX'
__this__=$(basename $0)

readonly VERSION_TEXT="$__this__ v$__version__"
readonly BANNER_TEXT="$VERSION_TEXT
$__copyright__
License: $__license__
$__github__
"
readonly HELP_TEXT="goprox - import and process GoPro media files

Usage: goprox [commands] [options] [advanced options] ...

Commands:
  -a, --archive         archive source sdcard
  -i, --import          import media files
  -p, --process         process imported files
                        default: process imported files since last process run
                        all: process all imported files
                        val[ymwdHMS]: process files modified within the specified time period
  --clean               clean up source sdcard
                        checks if source is a GoPro sdcard format
  --firmware            update sdcard to the latest GoPro firmware version
                        labs: use GoPro Labs firmware
  --geonames            add geonames information to imported directories to enable time processing
  --mount               trigger mountpoint processing
                        will search for GoPro media card mountpoints and kick of processing
                        this is also leveraged by the goprox launch agent
  --setup               run program setup
  --test                run program tests
                        this option is reserved for developers who clone the GitHub project

Options:
  -h, --help            show this help message and exit
  -c, --copyright       add copyright information to processed files
  -l, --library         specify library directory
  -s, --source          specify source directory for media files commonly .
  -t, --timeshift       adjust timestamps of imported files
  -q, --quiet           run program quietly
  -v, --verbose         run program verbosely
  --config              specify config file
                        defaults to ~/.goprox
  --debug               run program in debug mode
  --time                specify time format for output
                        format: specify time format for output
  --version             show version information and exit

Advanced Options:
  --if                  specify conditional processing
                        condition: specify condition for processing
  --created-on          filter files by creation date
                        date: filter files created on the specified date
  --created-after       filter files by creation date
                        date: filter files created after the specified date
  --created-before      filter files by creation date
                        date: filter files created before the specified date
  --modified-on         filter files by modification date
                        date: filter files modified on the specified date
  --modified-after      filter files by modification date
                        date: filter files modified after the specified date
  --modified-before     filter files by modification date
                        date: filter files modified before the specified date
  --repair              repair imported files time information
                        created: repair file creation dates

For more detailed documentation type: man goprox  or visit $__github__
"

# Various defaults
readonly DEFAULT_CONFIG=~/.goprox
readonly DEFAULT_SOURCE="."
readonly DEFAULT_LIBRARY="~/goprox"
readonly DEFAULT_COPYRIGHT=""
readonly DEFAULT_GEONAMESACCT=""
readonly DEFAULT_GEONAMESFILE="geonames.json"
readonly DEFAULT_MOUNTOPTIONS=(--archive --import --clean --firmware)
readonly DEFAULT_TIMEFORMAT='%Y-%m-%d %H:%M:%S'
readonly DEFAULT_FILETYPES="JPG|MP4|360|JPEG|HEIC"
readonly TIMESTAMP_PRE='perl -pe '"'"'use POSIX strftime; $|=1; print strftime "['
readonly TIMESTAMP_POST='] ", localtime'"'"
readonly DEFAULT_OUTPUT='tee'
readonly DEFAULT_LOGLEVEL=2 #debug:0; info:1; warn:2; error:3
readonly DEFAULT_EXIFTOOL_LOGLEVEL0="-v2 -progress"
readonly DEFAULT_EXIFTOOL_LOGLEVEL1="-v1 -progress"
readonly DEFAULT_EXIFTOOL_LOGLEVEL2="-q -q -progress"
readonly DEFAULT_EXIFTOOL_LOGLEVEL3="-q -q -q"

readonly GOPROX=$(which $0)
readonly REALGOPROX=$(readlink -f $GOPROX)
readonly GOPROX_HOME=$(dirname $REALGOPROX)

readonly DEFAULT_LOCKFILE=".goprox.lock"
readonly DEFAULT_ARCHIVED_MARKER=".goprox.archived"
readonly DEFAULT_IMPORTED_MARKER=".goprox.imported"
readonly DEFAULT_CLEANED_MARKER=".goprox.cleaned"
readonly DEFAULT_FWCHECKED_MARKER=".goprox.fwchecked"

# Initializing...
config=$DEFAULT_CONFIG
source=$DEFAULT_SOURCE
library=$DEFAULT_LIBRARY
geonamesacct=$DEFAULT_GEONAMESACCT
geonamesfile=$DEFAULT_GEONAMESFILE
copyright=$DEFAULT_COPYRIGHT
mountoptions=$DEFAULT_MOUNTOPTIONS
output=$DEFAULT_OUTPUT
filetypes=$DEFAULT_FILETYPES
loglevel=$DEFAULT_LOGLEVEL
exifloglevel=$DEFAULT_EXIFTOOL_LOGLEVEL2

test=false
setup=false
debug=false
import=false
process=false
geonames=false
archive=false
clean=false
firmware=false
version=false
mount=false

sourceopt=""
libraryopt=""
processopt=""
copyrightopt=""
geonamesopt=""
firmwareopt=""
mountopt=""

# filter options 
filter=false
createdfilter=false
createdonopt=""
createdafteropt=""
createdbeforeopt=""
ifopt=""
modifiedfilter=false
modifiedonopt=""
modifiedafteropt=""
modifiedbeforeopt=""
iffilter=() # default is empty array for later parameter expansion

# The api filter is used to rename camera models globally
apifilter=()
apifilter+=('Filter=s/HERO11 Black/GoPro_Hero11/g;')
apifilter+=('s/HERO11 Black Mini/GoPro_Hero11_Mini/g;')
apifilter+=('s/HERO10 Black/GoPro_Hero10/g;')
apifilter+=('s/HERO9 Black/GoPro_Hero9/g;')
apifilter+=('s/HERO8 Black/GoPro_Hero8/g;')
apifilter+=('s/GoPro Max/GoPro_Max/g')

exiftoolstatus=0
validlibrary=false
validarchive=false
validimported=false
validprocessed=false
validdeleted=false
tempdir=""

function _debug()
{
  if [[ $loglevel -le 0 ]] ; then
    echo $fg[blue]"Debug: "$1 $2$reset_color
    logger -t "goprox" -p user.debug "goprox: Debug: "$1 $2
  fi
}

function _info()
{
  if [[ $loglevel -le 1 ]] ; then
    echo $fg[green]"Info: "$1 $2$reset_color
    logger -t "goprox" -p user.info "goprox: Info: "$1 $2
  fi
}

function _echo()
{
  if [[ $loglevel -le 2 ]] ; then
    echo $fg[green]$1 $2$reset_color
    logger -t "goprox" -p user.notice "goprox: "$1 $2
  fi
}

function _warning()
{
  if [[ $loglevel -le 2 ]] ; then
    echo $fg[yellow]"Warning: "$1 $2$reset_color
    logger -t "goprox" -p user.warning "goprox: Warning: "$1 $2
  fi
}

function _error()
{
  if [[ $loglevel -le 3 ]] ; then
    >&2 echo $fg[red]"Error: "$1 $2$reset_color
    logger -t "goprox" -p user.error -s "goprox: Error: "$1 $2
  fi
}

function _help()
{
  echo $HELP_TEXT
}

function _validate_dependencies()
{
  # only works if the exiftool is installed
  _info "Validating exiftool..."
  if (( ${+commands[exiftool]} )); then
      [[ $loglevel -le 1 ]] && which exiftool
      if [[ "$debug" = true ]]; then
        exiftool -ver -v
      else
        [[ $loglevel -le 1 ]] && exiftool -ver
      fi
  else
      _error "ERROR: Please install exiftool first, run:"
      _warning "brew install exiftool"
      exit 1
  fi
  # jq is needed to parse and write json data
  _info "Validating jq..."
  if (( ${+commands[jq]} )); then
      [[ $loglevel -le 1 ]] && which jq && jq --version
  else
      _error "ERROR: Please install jq first, run:"
      _warning "brew install jq"
      exit 1
  fi
}


function _test_library_component()
{
  # $1 ... library component name (for logging)
  # $2 ... library component path (to be tested)
  # returns 0 if successfully validated, 1 if not

  if [[ -L "$2" ]] ; then
    librarylink=$(readlink -f $2)
    if [[ -e "$2" ]] ; then
        # Valid link
        _info "goprox $1: $2 is valid link to $librarylink"
    else
        # Broken link
        _warning "goprox $1: $2 is a broken link to $librarylink"
        _warning "Make sure the storage device is mounted and the directory has not been moved."
        return 2
    fi
  elif [[ -d "$2" ]] ; then
    # valid directory
    _info "goprox $1: $2 directory validated"
  else
    # completly missing 
    _warning "goprox $1: $2 directory or link is missing"

    _info "Creating $2 directory..."
    mkdir $2 || {
      _error "Failed to create $2 directory."
      return 1      
    }
  fi

  # All validation checks have been successful
  return 0
}


function _validate_storage()
{
  # perform test to validate the storage hierarchy
  _info "Validating storage hierarchy..."

    # Start with the root and validate its existence
  _test_library_component "library" "${library/#\~/$HOME}" && validlibrary=true

  # Only test the subtree if the root library is valid
  if [[ $validlibrary = true ]] ; then
    _test_library_component "archive" "${library/#\~/$HOME}/archive" && validarchive=true
    _test_library_component "imported" "${library/#\~/$HOME}/imported" && validimported=true
    _test_library_component "processed" "${library/#\~/$HOME}/processed" && validprocessed=true
    _test_library_component "deleted" "${library/#\~/$HOME}/deleted" && validdeleted=true
  fi

  _info "Finished storage hierarchy validation."
}

function _setup()
{
  # check if file exists
  if [[ -f "${config/#\~/$HOME}" ]]; then
    _info "Existing $config file."
    timestamp=`date +%s`
    backup="${config/#\~/$HOME}.bak.$timestamp"
    _info "Creating backup: $backup"
    mv "${config/#\~/$HOME}" "${backup/#\~/$HOME}"
  fi
  touch "${config/#\~/$HOME}"

  if [ $? -ne 0 ]
  then
    _error "Unable to create config file: $config"
    exit(1)
  fi

  _info "Source: "$source
  _info "Library: "$library
  _info "Copyright: "$copyright
  _info "GeoNamesAcct: "$geonamesacct

  _info "Writing config file: $config"
  echo "source="$source>>"${config/#\~/$HOME}"
  echo "library=\""$library"\"">>"${config/#\~/$HOME}"
  echo "copyright=\""$copyright"\"">>"${config/#\~/$HOME}"
  echo "geonamesacct=\""$geonamesacct"\"">>"${config/#\~/$HOME}"
  echo "mountoptions=(${mountoptions})">>"${config/#\~/$HOME}"
  _info "Config saved as $config"

  # check if library exists, otherwise create the skeleton
  _validate_storage

  _info "Finished setup task."
}

function _create_timefilter()
{
  if [[ $filter = false ]] ; then
    _debug "Nothing to filter."
    return 0
  fi

  # Assemble time filter based on various filter options:
  # --created-on:[date]
  # --created-after:[date]
  # --created-before:[date]
  # --modified-on:[date]
  # --modified-after:[date]
  # --modified-before:[date]
  _info "Creating time filter..."

  if [[ $createdfilter = true ]] ; then
    _debug "FileCreatedDate filter assembly"

    if [[ -n $createdonopt ]]; then
      _debug "CreatedOnFilter: "${createdonopt}
      # Need to assemble as an array to preserve whitespaces within $ifopt
      iffilter+='-if4'
      iffilter+='${FileCreateDate#;DateFmt("%Y%m%d%H%M%S")} =~ "'${createdonopt}'"'
    elif [[ -n $createdafteropt && -n $createdbeforeopt ]]; then
      iffilter+='-if4'
      iffilter+='${FileCreateDate#;DateFmt("%Y%m%d%H%M%S")} ge "'${createdafteropt}'"'\
' and ${FileCreateDate#;DateFmt("%Y%m%d%H%M%S")} lt "'${createdbeforeopt}'"'
    elif [[ -n $createdafteropt ]]; then
      iffilter+='-if4'
      iffilter+='${FileCreateDate#;DateFmt("%Y%m%d%H%M%S")} ge "'${createdafteropt}'"'
    elif [[ -n $createdbeforeopt ]]; then
      iffilter+='-if4'
      iffilter+='${FileCreateDate#;DateFmt("%Y%m%d%H%M%S")} lt "'${createdbeforeopt}'"'
    else
      _error "Invalid filter options."
      return 1
    fi
  fi

  if [[ $modifiedfilter = true ]] ; then
    _debug "FileModifiedDate filter assembly"

    if [[ -n $modifiedonopt ]]; then
      _debug "ModifiedOnFilter: "${modifiedonopt}
      # Need to assemble as an array to preserve whitespaces within $ifopt
      iffilter+='-if4'
      iffilter+='${FileModifyDate#;DateFmt("%Y%m%d%H%M%S")} =~ "'${modifiedonopt}'"'
    elif [[ -n $modifiedafteropt && -n $modifiedbeforeopt ]]; then
      iffilter+='-if4'
      iffilter+='${FileModifyDate#;DateFmt("%Y%m%d%H%M%S")} ge "'${modifiedafteropt}'"'\
' and ${FileModifyDate#;DateFmt("%Y%m%d%H%M%S")} lt "'${modifiedbeforeopt}'"'
    elif [[ -n $modifiedafteropt ]]; then
      iffilter+='-if4'
      iffilter+='${FileModifyDate#;DateFmt("%Y%m%d%H%M%S")} ge "'${modifiedafteropt}'"'
    elif [[ -n $modifiedbeforeopt ]]; then
      iffilter+='-if4'
      iffilter+='${FileModifyDate#;DateFmt("%Y%m%d%H%M%S")} lt "'${modifiedbeforeopt}'"'
    else
      _error "Invalid filter options."
      return 1
    fi
  fi

  _info "Finished time filter."

  return 0
}

function _create_iffilter()
{
  if [[ $filter = false ]] ; then
    _debug "Nothing to filter."
    return 0
  fi

  _info "Creating if filter..."

  if [[ -n $ifopt ]]; then
    _debug "IfFilter: "${ifopt}

    # Need to assemble as an array to preserve whitespaces within $ifopt
    iffilter+='-if0'
    iffilter+="${ifopt}"
  fi

  _info "Finished if filter..."
  
  return 0
}

function _import_media()
{
  if [[ $validimported = false ]] ; then
    _error "Invalid imported directory. Cannot proceed with import."
    exit 1
  fi
  importdir=$library/imported
  _echo "Starting media import..."
  _info "Source: $source ($(realpath "${source/#\~/$HOME}"))"
  _info "Library: $importdir ($(realpath "${importdir/#\~/$HOME}"))"

  # Remove previous import marker
  rm -f $source/$DEFAULT_IMPORTED_MARKER

  exiftool -r $=exifloglevel "${iffilter[@]}" -o "${importdir}"'/NODATE/'\
  '-FileCreateDate<FileCreateDate'\
  '-FileCreateDate<CreateDate'\
  '-filename<${FileName}'\
  '-filename<${FileCreateDate;DateFmt("%Y%m%d%H%M%S")}_NODATA_%f.%e'\
  '-filename<${CreateDate;DateFmt("%Y%m%d%H%M%S")}_NODATA_%f.%e'\
  '-filename<${CreateDate;DateFmt("%Y%m%d%H%M%S")}_'\
'${Model;s/\s/_/g;}_%f.%e'\
  '-filename<${CreateDate;DateFmt("%Y%m%d%H%M%S")}_'\
'${Encoder;s/\s/_/g;}_%f.%e'\
  '-filename<${CreateDate;DateFmt("%Y%m%d%H%M%S")}_'\
'${Model;s/\s/_/g;}_'\
'${CameraSerialNumber;$_=substr($_,-4);}_%f.%e'\
  '-directory<'"${importdir}"'/${FileCreateDate;DateFmt("%Y")}/${FileCreateDate;DateFmt("%Y%m%d")}'\
  '-directory<'"${importdir}"'/${CreateDate;DateFmt("%Y")}/${CreateDate;DateFmt("%Y%m%d")}'\
  -if '$MIMEType=~/image/ or $MIMEType=~/video/'\
  --ext lrv --ext thm --ext xmp --ext . --ext tar --ext gz --ext zip --ext dmg\
  -api "${apifilter}"\
  "${source}" || {
    # exiftool reported one or more errors
    exiftoolstatus=$?
    _warning "exiftool reported one or more errors. Please check output."
  }

  _echo "Finished media import"

  # Leave a marker
  touch $source/$DEFAULT_IMPORTED_MARKER
}

function _process_media()
{
  if [[ $validimported = false || $validexported = false ]]  ; then
    _error "Invalid imported and/or processed directory. Cannot proceed with processing."
    exit 1
  fi
  importdir=$library/imported
  processdir=$library/processed
  _echo "Starting media processing..."
  _info "ImportDir: "$importdir
  _info "ProcessDir: "$processdir
  _info "Process option: "$processopt

  if [[ -n $copyright ]]; then
    _info "Copyright: "$copyright
    artist="-artist="${copyright}
    author="-author="${copyright}
    xmpcopyright="-xmp:copyright="${copyright}
  fi

  # Only process files that have changed since we last ran
  # TODO: Needs to be hardened for various edge cases
  # Right now this will skip files if eg a single manual edit happens in the
  # processed tree or a processing run gets aborted.
  if [[ $filter = false ]] ; then
    # Get the latest modification date in the processdir
    # zsh -c 'zmodload zsh/stat; stat +mtime -- **/*(.om[1])'
    # -if '${FileModifyDate;DateFmt("%s")} gt '"\"$(stat -f %m temp)"\"...
    lastprocess=$(stat +mtime -- ${processdir}/**/*(.om[1]))
    _debug "Latest process timestamp: ${lastprocess}"

    lastimport=$(stat +mtime -- ${importdir}/**/*(.om[1]))
    _debug "Latest import timestamp: ${lastimport}"

    if [[ $processopt == "all" ]]; then
      _info "Requested processing: ${processopt}. Processing all files from ${importdir}"
    elif [[ $processopt == *[0-9](y|m|w|d|H|M|S) ]]; then
      _info " Processing the past ${processopt} of imported media files."

      deltadate=$(date -v-${processopt} +%s)
      _debug "Delta date: ${deltadate}"

      iffilter+='-if4'
      iffilter+='${FileModifyDate#;DateFmt("%s")} gt '${deltadate}
    elif [[ -n $processopt ]]; then
      _error "Unknown processing option: ${processopt} specified."
      exit 1
    elif [[ -n $lastprocess ]]; then
      iffilter+='-if4'
      iffilter+='${FileModifyDate#;DateFmt("%s")} gt '${lastprocess}
    else
      _info "Process dir ${processdir} is empty. Processing all files from ${importdir}"
    fi
  fi

  # The following keywords and tags are being created and added in order to
  # make our image files exif data accessible inside of Apple Photos and other
  # Applications. By turning them into tags inside of Photos, they can be used
  # to filter, sort or setup smart albums.
  # Not every camera model and firmware supports all of these tags, hence the
  # incremental additions that allow missing data to be omitted without error.

  local exififd=()
  exififd+=('-ExifIFD:LensMake-=')
  exififd+=('-ExifIFD:LensMake<${Make;}')
  exififd+=('-ExifIFD:LensModel-=')
  exififd+=('-ExifIFD:LensModel<${Make;}')
  exififd+=('-ExifIFD:LensModel<${Make;} - ${ExifIFD:FocalLength;} f/${ExifIFD:FNumber}')

  # GPS keys needed for Apple Photos to recognize the location of a video
  local gpsdata=()
  gpsdata+=('-Keys:GPSCoordinates-=')
  gpsdata+=('-Keys:GPSCoordinates<${GPSLatitude;}, ${GPSLongitude;}, 0')

  # Add lineage data to the processed media files.
  local xmpdata=()
  # Need definied positions for entries that vary by processing pass
  xmpdata+=('-XMP:PreservedFileName<P_${FileName;s/\.[^.]*$//}.${FileTypeExtension}') # Must be first entry

  # Add tags for Apple Photos
  local taglist=()

  # HERO 10 jpg examples:
  # [GoPro]         DeviceName                      : Global Settings
  # [GoPro]         MetadataVersion                 : 8 1 4
  # [GoPro]         FirmwareVersion                 : H21.01.01.10.00
  # [GoPro]         CameraSerialNumber              : C3461324698034
  # [GoPro]         Model                           : HERO10 Black
  # [GoPro]         AutoRotation                    : U
  # [GoPro]         DigitalZoom                     : N
  # [GoPro]         ProTune                         : Y
  # [GoPro]         WhiteBalance                    : AUTO
  # [GoPro]         Sharpness                       : MED
  # [GoPro]         ColorMode                       : GOPRO
  # [GoPro]         AutoISOMax                      : 3200
  # [GoPro]         AutoISOMin                      : 100
  # [GoPro]         ExposureCompensation            : 0.0
  # [GoPro]         Rate                            : 1
  # [GoPro]         PhotoResolution                 : 20MP_N
  # [GoPro]         HDRSetting                      : S_HDR

  # HERO 10 mp4 example:
  # [GoPro]         DeviceName                      : Global Settings
  # [GoPro]         MetadataVersion                 : 8 1 4
  # [GoPro]         FirmwareVersion                 : H21.01.01.10.00
  # [GoPro]         CameraSerialNumber              : C3461324698034
  # [GoPro]         Model                           : HERO10 Black
  # [GoPro]         AutoRotation                    : U
  # [GoPro]         DigitalZoom                     : N
  # [GoPro]         ProTune                         : Y
  # [GoPro]         WhiteBalance                    : AUTO
  # [GoPro]         Sharpness                       : MED
  # [GoPro]         ColorMode                       : NATURAL
  # [GoPro]         AutoISOMax                      : 1600
  # [GoPro]         AutoISOMin                      : 100
  # [GoPro]         ExposureCompensation            : 0.0
  # [GoPro]         Rate                            :
  # [GoPro]         FieldOfView                     : N
  # [GoPro]         ElectronicImageStabilization    : HS Boost
  # [GoPro]         AudioSetting                    : AUTO
  # [GoPro]         DeviceName                      : Highlights

  function _create_tag_list()
  {
    # exclude goprox version tag when testing to avoid changed files due to version numbering
    if [ "$test" != true ]; then
      taglist+=('-'$1'=GoProX: '${__version__})
    fi
    taglist+=('-'$1'+<Make: ${Make;s/\s/_/g;}')
    taglist+=('-'$1'+<Camera: ${Model;s/\s/_/g;}')
    taglist+=('-'$1'+<Camera: ${Model;s/\s/_/g;}_${CameraSerialNumber;$_=substr($_,-4);}')
    taglist+=('-'$1'+<Software: ${Software;}')
    taglist+=('-'$1'+<AutoRotation: ${AutoRotation;}')
    taglist+=('-'$1'+<Orientation: ${Orientation;}')
    taglist+=('-'$1'+<DigitalZoom: ${DigitalZoom;}')
    taglist+=('-'$1'+<SceneCaptureType: ${SceneCaptureType;}')
    taglist+=('-'$1'+<ProTune: ${ProTune;}')
    taglist+=('-'$1'+<Sharpness: ${Sharpness;}')
    taglist+=('-'$1'+<ColorMode: ${ColorMode;}')
    taglist+=('-'$1'+<AutoISOMax: ${AutoISOMax;}')
    taglist+=('-'$1'+<AutoISOMin: ${AutoISOMin;}')
    taglist+=('-'$1'+<MeteringMode: ${MeteringMode;}')
    taglist+=('-'$1'+<GainControl: ${GainControl;}')
    taglist+=('-'$1'+<Contrast: ${Contrast;}')
    taglist+=('-'$1'+<Saturation: ${Saturation;}')
    taglist+=('-'$1'+<WhiteBalance: ${WhiteBalance;}')
    taglist+=('-'$1'+<PhotoResolution: ${PhotoResolution;}')
    taglist+=('-'$1'+<HDRSetting: ${HDRSetting;}')
    taglist+=('-'$1'+<ExposureCompensation: ${ExposureCompensation;}')
    taglist+=('-'$1'+<FieldOfView: ${FieldOfView;}')
    taglist+=('-'$1'+<FieldOfView: ${FieldOfView;}')
    taglist+=('-'$1'+<ExposureLockUsed: ${ExposureLockUsed;}')
    taglist+=('-'$1'+<ProjectionType: ${ProjectionType;}')
    taglist+=('-'$1'+<ImageStabilization: ${ElectronicImageStabilization;}')
    taglist+=('-'$1'+<AudioSetting: ${AudioSetting;}')
  }

  # Now populate tag lists...
  _create_tag_list 'XMP:Subject'
  _create_tag_list 'IPTC:Keywords'
  # _create_tag_list 'ItemList:Keyword'
  # _create_tag_list 'Quicktime:Keywords'

  # Additional Quicktime tags for movies
  local quicktimedata=()
  quicktimedata+=('-Keys:Make<${Make;}')
  quicktimedata+=('-Keys:Model<${Model;}')
  # quicktimedata+=('-Keys:Information=My Information')
  # quicktimedata+=('-Keys:Description=My Description')
  # quicktimedata+=('-Keys:Keywords="GoProX:'${__version__}'","Make:MyGoPro"')

  # Additional data...
  #
  # Inspect raw GPS data:
  # exiftool -s -a '-gps*' -n -G FILE
  #
  # To consider adding for timeshift functionality...
  # 0x882a	TimeZoneOffset	int16s[n]	ExifIFD	(1 or 2 values: 1. The time zone offset of DateTimeOriginal from GMT in hours, 2. If present, the time zone offset of ModifyDate)
  # 0x9011	OffsetTimeOriginal	string	ExifIFD	(time zone for DateTimeOriginal)

  # First pass - exlude mp4 and 360 files
  _echo "First pass: 1/4 - All files but mp4 and 360"

# exiftool -r -F -sep ", " -q -q -progress -addTagsFromFile @ -o "${processdir}"'/NODATE/'\
  exiftool -r -F -sep ", " $=exifloglevel "${iffilter[@]}" -addTagsFromFile @ -o "${processdir}"'/NODATE/'\
  '-FileCreateDate<FileCreateDate'\
  '-FileCreateDate<CreateDate'\
  '-filename<P_%f.${FileTypeExtension}'\
  '-directory<'"${processdir}"'/${FileType}/${FileCreateDate;DateFmt("%Y")}/${FileCreateDate;DateFmt("%Y%m%d")}'\
  '-directory<'"${processdir}"'/${FileType}/${CreateDate;DateFmt("%Y")}/${CreateDate;DateFmt("%Y%m%d")}'\
  "${artist}"\
  "${author}"\
  "${xmpcopyright}"\
  "${exififd[@]}"\
  "${taglist[@]}"\
  "${xmpdata[@]}"\
  --ext mp4 --ext 360\
  -api "${apifilter}"\
  -api largefilesupport=1\
  "${importdir}" || {
    # exiftool reported one or more errors
    exiftoolstatus=$?
    if [[ $exiftoolstatus = 2 ]]; then
      _warning "First pass: No files processed by exiftool."
    else  
      _warning "First pass: exiftool reported one or more errors. Please check output."
    fi
  }

  # Second pass - only mp4 files
  # Need to apply different logic for various tags
  _echo "Second pass: 2/4 - Only mp4 files"

# exiftool -r -F -sep ", " -q -q -progress -addTagsFromFile @ -o "${processdir}"'/NODATE/'\
  exiftool -r -F -sep ", " $=exifloglevel "${iffilter[@]}" -addTagsFromFile @ -o "${processdir}"'/NODATE/'\
  '-FileCreateDate<FileCreateDate'\
  '-FileCreateDate<CreateDate'\
  '-filename<P_%f.${FileTypeExtension}'\
  '-directory<'"${processdir}"'/${FileType}/${FileCreateDate;DateFmt("%Y")}/${FileCreateDate;DateFmt("%Y%m%d")}'\
  '-directory<'"${processdir}"'/${FileType}/${CreateDate;DateFmt("%Y")}/${CreateDate;DateFmt("%Y%m%d")}'\
  "${artist}"\
  "${author}"\
  "${xmpcopyright}"\
  "${exififd[@]}"\
  "${taglist[@]}"\
  "${gpsdata[@]}"\
  "${quicktimedata[@]}"\
  "${xmpdata[@]}"\
  -ext mp4\
  -api "${apifilter}"\
  -api largefilesupport=1\
  -api QuickTimeHandler=1\
  "${importdir}" || {
    # exiftool reported one or more errors
    exiftoolstatus=$?
        if [[ $exiftoolstatus = 2 ]]; then
      _warning "Second pass: No files processed by exiftool."
    else  
      _warning "Second pass: exiftool reported one or more errors. Please check output."
    fi
  }

  # Third pass - only 360 files
  # Need to apply different logic for various tags and sort into 360 subtree
  _echo "Third pass: 3/4 - Only 360 files"

  # Override - File name pattern is different for 360 media
  xmpdata[1]='-XMP:PreservedFileName<P_${FileName;s/\.[^.]*$//}.360'

# exiftool -r -F -sep ", " -q -q -progress -addTagsFromFile @ -o "${processdir}"'/NODATE/'\
  exiftool -r -F -sep ", " $=exifloglevel "${iffilter[@]}" -addTagsFromFile @ -o "${processdir}"'/NODATE/'\
  '-FileCreateDate<FileCreateDate'\
  '-FileCreateDate<CreateDate'\
  '-filename=P_%f.%e'\
  '-directory<'"${processdir}"'/%e/${FileCreateDate;DateFmt("%Y")}/${FileCreateDate;DateFmt("%Y%m%d")}'\
  '-directory<'"${processdir}"'/%e/${CreateDate;DateFmt("%Y")}/${CreateDate;DateFmt("%Y%m%d")}'\
  "${artist}"\
  "${author}"\
  "${xmpcopyright}"\
  "${exififd[@]}"\
  "${taglist[@]}"\
  "${gpsdata[@]}"\
  "${quicktimedata[@]}"\
  "${xmpdata[@]}"\
  -ext 360\
  -api "${apifilter}"\
  -api largefilesupport=1\
  -api QuickTimeHandler=1\
  "${importdir}" || {
    # exiftool reported one or more errors
    exiftoolstatus=$?
    if [[ $exiftoolstatus = 2 ]]; then
      _warning "Third pass: No files processed by exiftool."
    else  
      _warning "Third pass: exiftool reported one or more errors. Please check output."
    fi
  }

  # Forth pass - timeshift gopro video files
  # To eliminate issues with Apple & Google photos we need to convert the QuickTime date/time 
  # fields into UTC. Since GoPro records those fields in local time of the camera, we need to 
  # leverage the GPSDateTime to calculate the approx DST offset and then shift all the 
  # QuickTime tags by that amount.
  _echo "Forth pass: 4/4 - Only mp4 & 360 files - timeshift QuickTime to UTC"

# exiftool -r -wm w -ee -d '%s' -q -q -progress -P -overwrite_original_in_place\
  exiftool -r -wm w -ee -d '%s' $=exifloglevel "${iffilter[@]}" -P -overwrite_original_in_place\
  '-quicktime:time:all<${GPSDateTime;$_=$self->GetValue("CreateDate")+'\
'int((($_-$self->GetValue("CreateDate"))/3600)+(($_-$self->GetValue("CreateDate"))/3600)/'\
'abs((($_-$self->GetValue("CreateDate"))/3600)*2 || 1))*3600}'\
  -ext mp4 -ext 360\
  -api "${apifilter}"\
  -api largefilesupport=1\
  -api QuickTimeHandler=1\
  -api TimeZone=GMT\
  "${processdir}" || {
    # exiftool reported one or more errors
    exiftoolstatus=$?
    if [[ $exiftoolstatus = 2 ]]; then
      _warning "Forth pass: No files processed by exiftool."
    else  
      _warning "Forth pass: exiftool reported one or more errors. Please check output."
    fi
  }

  _echo "Finished media processing"
}

function _geonames_media()
{
  if [[ $validimported = false ]] ; then
    _error "Invalid imported directory. Cannot proceed with geonames task."
    exit 1
  fi

  importdir=$library/imported

  _echo "Starting GeoNames processing..."
  _info "Library: "$library
  _info "ImportDir: "$importdir
  _info "GeoNames account: "$geonamesacct

  # case independent globing
  unsetopt CASE_GLOB
  ndir=0
  ngeo=0
  for d in ${importdir}/**/; do # all subdirectories of import
    if [[ $d =~ .*/[0-9]{8} ]]; then # only those that match an 8 digit date
      if [[ ! -f "${d}${geonamesfile}" ]]; then
        _info "Processing "$d
        ((ndir++))

        # Find first media file with valid gps exif data
        _debug "Filetypes: "$filetypes

        # for file in "$d"*.(JPG|MP4|360|JPEG|HEIC)(N); do
        for file in "$d"*.($~filetypes)(N); do
          _info "Media file: "$file

          # Get GPS info from file
          # @todo Add exiftool error handling
          # @body Need to test exiftool for errors  
          gpsdata=$(exiftool -n -q -q \
                    -p 'lat=$gpslatitude&lng=$gpslongitude' "$file" | head -n 1)
          _debug "GPS Data: "$gpsdata

          # Check if gpsdata is empty = no match for the simplified GPS tag search
          if [[ -z $gpsdata ]]; then
            gpsdata=$(exiftool -n -ee -q -q -p 'lat=$gpslatitude&lng=$gpslongitude' "$file" | head -n 1)
            _debug "Extended GPS Data: "$gpsdata
          fi

          if [[ -n $gpsdata ]]; then
            geonamesdata=$(curl -s 'http://api.geonames.org/timezoneJSON?'${gpsdata}'&username='${geonamesacct})
            _debug "GeoNames Data: "$geonamesdata
            _info "Writing GeoNames file: ${d}${geonamesfile}"

            # Add our current file as reference
            # @todo Add geonames error handling
            # @body Add check if geonames call resulted in valid geonames data, at the minimum that it is not empty
            echo $geonamesdata | jq ". + {reference: \"${file}\"}">${d}${geonamesfile}
            ((ngeo++))

            # Delay subsequent geonames calls to stay within free geonames account limits
            sleep 2

            break
          fi
        done
      fi
    fi
  done

  _info "$ndir directories processed."
  _info "$ngeo GeoNames files created."

  _echo "Finished GeoNames processing"
}


function _timeshift_media()
{
  if [[ $validimported = false || $validexported = false ]]  ; then
    _error "Invalid imported and/or processed directory. Cannot proceed with processing."
    exit 1
  fi
  importdir=$library/imported
  processdir=$library/processed

  # TODO: Implement timeshift functionality
  geooffset=$(TZ=Europe/Vienna date -j -f "%Y%m%d" "20200601" "+%z")
  _debug "GeoOffset: "$geooffset
  # /TODO
}


function _archive_media()
{
  if [[ $validarchive = false ]] ; then
    _error "Invalid archive directory. Cannot proceed with archive."
    exit 1
  fi

  archivedir=$library/archive
  _echo "Starting media archive..."
  _info "Source: $source ($(realpath "${source/#\~/$HOME}"))"
  _info "Library: $archivedir ($(realpath "${archivedir/#\~/$HOME}"))"

  # Remove previous archive marker
  rm -f $source/$DEFAULT_ARCHIVED_MARKER

  # Check if this is a GoPro storage card
  if [[ -f "$source/MISC/version.txt" ]]; then

    # Extract camera model and firmware version
    # Due to some broken version.txt files for some models and firmware versions
    # we have to apply a rather complicated looking fix: remove comma from the
    # end of the second to last line in the file:
    # sed -e x -e '$ {s/,$//;p;x;}' -e 1d ./MISC/version.txt
    # Otherwise we could simply cat
    # camera=$(cat MISC/version.txt | jq '."camera type"')
    # camera=$(sed -e x -e '$ {s/,$//;p;x;}' -e 1d ./MISC/version.txt | jq '."camera type"')
    camera=$(sed -e x -e '$ {s/,$//;p;x;}' -e 1d $source/MISC/version.txt | jq -r '."camera type"')
    serial=$(sed -e x -e '$ {s/,$//;p;x;}' -e 1d $source/MISC/version.txt | jq -r '."camera serial number"')
    timestamp=$(date +%Y%m%d%H%M%S)

    _info "Camera: "${camera}
    _info "Serial: "${serial:(-4)}
    _info "Time: "$timestamp

    archivename=${timestamp}_${camera// /_}_${serial:(-4)}

    _info "Archive: "$archivename

    tar --totals --exclude='.Spotlight-V100' --exclude='.Trash*' --exclude='.goprox.*' \
        -zcvf "${archivedir}"/"${archivename}".tar.gz $source || {
      # Archive failed
      _error "Archive creation failed!"
      exit 1
    }
  else
    _error "Cannot verify that $(realpath ${source}) is a GoPro storage device"
    _error "Missing $(realpath ${source})/MISC/version.txt"
    exit 1
  fi

  _echo "Finished media archive"

  # Leave a marker
  touch $source/$DEFAULT_ARCHIVED_MARKER
}

function _clean_media()
{
  _echo "Cleaning Source Media..."
  _info "Source: $source ($(realpath "${source/#\~/$HOME}"))"

  # Remove previous clean marker
  rm -f $source/$DEFAULT_CLEANED_MARKER

  # Check if this is a GoPro storage card
  if [[ -f "$source/MISC/version.txt" ]]; then
    # Only proceed if we just finished archiving or importing this media
    if [ "$archive" = true ] || [ "$import" = true ]; then
      # One more check to make sure any prior step did not result in an exiftool error
      _debug "exiftool status: $exiftoolstatus"
      if (( $exiftoolstatus )) then
        _error "Will not clean ${source} ($(realpath "${source/#\~/$HOME}")) due to exiftool error status: ${exiftoolstatus}"
        _error "Please check output."
        exit 1
      fi
      if [ -e "$source/DCIM" ]; then
        _debug "Removing $source/DCIM"
        rm -rfv $source/DCIM || {
          # Cleanup failed
          _error "Cleaning ${source} ($(realpath "${source/#\~/$HOME}")) failed!"
          exit 1
        }
      fi
      for xfile in $source/mdb*(N); do
        _debug "Removing $xfile"
        rm -rfv $xfile || {
          # Cleanup failed
          _error "Cleaning ${source} failed!"
          exit 1
        }
      done
    else
      _error "Will not clean ${source} ($(realpath "${source/#\~/$HOME}")) without prior archive or import"
      _error "Run options --archive or --import and --clean together"
      exit 1
    fi
  else
    _error "Will not clean ${source} ($(realpath "${source/#\~/$HOME}")) cannot verify it is a GoPro storage device"
    _error "Missing $source/MISC/version.txt ($(realpath "${source/#\~/$HOME}"/MISC/version.txt))"
    exit 1
  fi

  _echo "Finished cleanup tasks"

  # Leave a marker
  touch $source/$DEFAULT_CLEANED_MARKER
}

function _firmware()
{
  _echo "Checking firmware..."
  _info "Source: $source ($(realpath "${source/#\~/$HOME}"))"

  # Check if this is a GoPro storage card
  if [[ -f "$source/MISC/version.txt" ]]; then
    # Remove previous firmware marker
    rm -f $source/$DEFAULT_FWCHECKED_MARKER

    # Extract camera model and firmware version
    # Due to some broken version.txt files for some models and firmware versions
    # we have to apply a rather complicated looking fix: remove comma from the
    # end of the second to last line in the file:
    # sed -e x -e '$ {s/,$//;p;x;}' -e 1d ./MISC/version.txt
    # Otherwise we could simply cat
    # camera=$(cat MISC/version.txt | jq '."camera type"')
    # camera=$(sed -e x -e '$ {s/,$//;p;x;}' -e 1d ./MISC/version.txt | jq '."camera type"')
    camera=$(sed -e x -e '$ {s/,$//;p;x;}' -e 1d $source/MISC/version.txt | jq -r '."camera type"')
    version=$(sed -e x -e '$ {s/,$//;p;x;}' -e 1d $source/MISC/version.txt | jq -r '."firmware version"')

    _info "Camera: ${camera}"
    _info "Version: ${version}"

    # Get the latest firmware for the device

    _debug "GoProX home: $GOPROX_HOME"
    if [[ $firmwareopt == "labs" ]]; then
      firmwarebase="${GOPROX_HOME}/firmware.labs/${camera}"
    else
      firmwarebase="${GOPROX_HOME}/firmware/${camera}"
    fi
    _debug "Firmware base: $firmwarebase"

    latestfirmware=`${firmwarebase}/*([-1])`
    _debug "Latest firmware: " ${latestfirmware}

    if [[ -z "$latestfirmware" ]]; then
      echo "No firmware files found at ${firmwarebase}"
      # nothing left todo
      return
    fi

    latestversion=`${latestfirmware:t}`
    _debug "Latest version: " ${latestversion}

    if [[ $latestversion != $version ]]; then
      _warning "New firmware available: ${version} >> ${latestversion}"
      _warning "Transferring newer firmware to ${source}"
      unzip -uj "${latestfirmware}"/*.zip -d "${source}/UPDATE" || {
        # Unzip failed
        _error "Unzip copy of firmware ${latestfirmware}/*.zip to ${source}/UPDATE failed!"
        exit 1
      }
      _info "Finished firmware transfer. Camera ${camera} will install upgrade during next power on."

    else
      _info "Camera ${camera} has the latest firmware: ${latestversion}"
    fi

    # Leave a marker - but in this case only if we ran against a verified GoPro volume
    touch $source/$DEFAULT_FWCHECKED_MARKER
  else
    _error "Cannot verify that $(realpath ${source}) is a GoPro storage device"
    _error "Missing $(realpath ${source})/MISC/version.txt"
    exit 1
  fi

  _echo "Finished firmware check."
}


# Enable color output
autoload colors
colors

# enable built in stat
zmodload zsh/stat

# If no parameters have been provided display help and exit
if [[ $# -eq 0 ]] ; then
  _help
  exit 1
fi

# Parse options
declare -A opts
zparseopts -D -E -F -A opts - \
            h -help \
            a -archive \
            c: -copyright: \
            i -import \
            l: -library: \
            p:: -process:: \
            s: -source: \
            t:: -timeshift:: \
            q -quiet \
            v -verbose \
            -clean \
            -config: \
            -created-on: \
            -created-after: \
            -created-before: \
            -debug \
            -firmware:: \
            -geonames:: \
            -if: \
            -modified-on: \
            -modified-after: \
            -modified-before: \
            -mount:: \
            -setup \
            -test \
            -time:: \
            -version \
	          || {
    # Unknown option
    _error "Unknown option: $@"
    exit 1
  }

# remove first -- or -
end_opts=$@[(i)(--|-)]
set -- "${@[0,end_opts-1]}" "${@[end_opts+1,-1]}"

for key val in "${(kv@)opts}"; do
  case $key in
    -h|--help)
      _help
      exit 1
    ;;
    -a|--archive)
      # Perform archive tasks
      archive=true
    ;;
    -c|--copyright)
      copyrightopt=$val
      #"-artist=$val -author=$val -xmp:copyright=$val"
    ;;
    -i|--import)
      # Perform import tasks
      import=true
    ;;
    -l|--library)
      libraryopt=$val
    ;;
    -p|--process)
      # Perform process tasks
      process=true
      # support for processing overrides
      # optional paremeter: all ((re)process all files), nd (n days of past
      # imports from now - eg 7d: process past 7 days of imported media)
      processopt=$val
    ;;
    -s|--source)
      sourceopt=$val
    ;;
    -t|--timeshift)
      # Perform process tasks
      timeshift=true
      # support for processing overrides
      # TODO: Implement variants like GPS and manual TZ
      timeshiftopt=$val
    ;;
    -q|--quiet)
      loglevel=3 # error
    ;;
    -v|--verbose)
      loglevel=1 # info
    ;;
    --clean)
      # Perform archive tasks
      clean=true
    ;;
    --config)
      config=$val
    ;;
    --created-on)
      # Filter on creation date; exiftool -if4
      filter=true
      createdfilter=true
      createdonopt=$val
    ;;
    --created-after)
      filter=true
      createdfilter=true
      createdafteropt=$val
    ;;
    --created-before)
      filter=true
      createdfilter=true
      createdbeforeopt=$val
    ;;
    --debug)
      # Turn on debug output
      debug=true
      # DEBUG output only works AFTER parameter processing has been completed
      # For manual script wide override set the $debug variable to true
    ;;
    --firmware)
      # setup firmware upgrade
      firmware=true
      # optional paremeter: labs
      # installs labs firmware for camera
      firmwareopt=$val
    ;;
    --geonames)
      geonames=true
      geonamesopt=$val
    ;;
    --if)
      # filter on metadata; exiftool -if
      filter=true
      ifopt=$val
    ;;
    --modified-on)
      # filter on modification date; exiftool -if4
      filter=true
      modifiedfilter=true
      modifiedonopt=$val
    ;;
    --modified-after)
      filter=true
      modifiedfilter=true
      modifiedafteropt=$val
    ;;
    --modified-before)
      filter=true
      modifiedfilter=true
      modifiedbeforeopt=$val
    ;;
    --mount)
      mount=true
      mountopt=$val
    ;;
    --setup)
      # Perform setup tasks
      setup=true
    ;;
    --test)
      test=true
      # Also timestamp when testing --time output
      output=$TIMESTAMP_PRE$DEFAULT_TIMEFORMAT$TIMESTAMP_POST
    ;;
    --time)
      if [[ ! -z $val ]]; then
        # Need to validate incoming timeformat as it is being used in eval code
        _dirtytimeformat=$val
        # Only copy alphanumeric and a few date & time formatting characters
        timeformat=${_dirtytimeformat//[^a-zA-Z0-9:%\-_ ]/}
      else
        timeformat=$DEFAULT_TIMEFORMAT
      fi
      output=$TIMESTAMP_PRE"$timeformat"$TIMESTAMP_POST
    ;;
    --version)
      version=true

      # if no other options have been provided, display version and exit
      if [[ $# -eq 1 ]] ; then
        echo $VERSION_TEXT
        exit 0
      fi
    ;
  esac
done

if [ "$debug" = true ]; then
  loglevel=0
  set -x
fi

# Set exiftool logging
case $loglevel in
  0)
  exifloglevel=$DEFAULT_EXIFTOOL_LOGLEVEL0
  ;;
  1)
  exifloglevel=$DEFAULT_EXIFTOOL_LOGLEVEL1
  ;;
  2)
  exifloglevel=$DEFAULT_EXIFTOOL_LOGLEVEL2
  ;;
  3)
  exifloglevel=$DEFAULT_EXIFTOOL_LOGLEVEL3
  ;;
esac

# so we can timestamp the output
(
_echo "GoProX started..."

if [ "$version" = true ]; then
  # Display version independent of logging level 
  echo $VERSION_TEXT
fi

_info $BANNER_TEXT

# Check if all required dependencies are installed
_validate_dependencies

# Load config file first
# Check if we have a config file to work with
if [[ -f "$config" ]]; then
  _info "Loading config file: $config"
  [[ $loglevel -le 1 ]] && tail $config
  source $config
fi

_debug "SourceOpt: $sourceopt"
_debug "LibraryOpt: $libraryopt"
_debug "CopyrightOpt: $copyrightopt"
_debug "GeonamesOpt: $geonamesopt"

# Create optional timefilters
# Must be executed BEFORE iffilter logic as exiftool -if4 must be left of -if0
_create_timefilter || {
  # failure during time filter creation
  _error "Invalid time filter."
  exit 1
}

# Create optional iffilters
# Must be executed AFTER timefilter logic as exiftool -if4 must be left of -if0
_create_iffilter || {
  # failure during time filter creation
  _error "Invalid time filter."
  exit 1
}

# Check if source is a tar.gz file
_sourcetype="${sourceopt#*.}"
_debug "Source type: $_sourcetype"

case $_sourcetype in
  tar.gz)
  # This is a gziped tar ball
  # Need to uncompress into a temp directory to proceed
  tempdir=`mktemp -d /tmp/${__this__}.XXXXXX` || {
      _error "Unable to create temp dir: $tempdir"
      exit 1
  }
  # Make sure it gets removed on exit
  trap 'rm -rf -- "$tempdir"' EXIT

  _info "Temp dir: $tempdir" 

  tar -xvf ${sourceopt} -C $tempdir || {
    # Archive extraction failed
    _error "Archive extraction failed!"
    exit 1
  }

  # Now make temp dir the source of processing
  sourceopt=$tempdir
  ;;
esac

# Now override any parameters that were specified
if [[ -n $sourceopt ]]; then
  source=$sourceopt
fi

if [[ -n $libraryopt ]]; then
  library=$libraryopt
fi

if [[ -n $copyrightopt ]]; then
  copyright=$copyrightopt
fi

if [[ -n $geonamesopt ]]; then
  geonamesacct=$geonamesopt
fi

_debug "Source: $source ($(realpath "${source/#\~/$HOME}"))"
_debug "Library: $library ($(realpath "${library/#\~/$HOME}"))"
_debug "Copyright: $copyright"
_debug "GeonamesAcct: $geonamesacct"

# Library is a mandatory config setting or parameter
if [ -z $library ] && [ "$test" != true ]; then
  # Empty Library
  _error "ERROR: Missing library!"
  _warning "Specifying library via -l: or --library: is mandatory."
  _warning "Or define in your ${config}.\n"
  _help
  exit 1
fi

if [ "$setup" = true ]; then
  # Setup config file for current user
  _setup
  exit 0
fi

if [ "$test" = true ]; then
  _echo "TESTING - Performing tests..."
  _info "Removing prior test data..."
  rm -r "./test/archive"
  rm -r "./test/imported"
  rm -r "./test/processed"

  _info "Setting up test structure..."
  mkdir "./test/archive"
  mkdir "./test/imported"
  mkdir "./test/processed"

  source="./test/originals"
  library="./test"
  _validate_storage
  _archive_media
  _import_media

  copyright="This is a Test Copyright"
  _process_media

  _info "Comparing test output..."
  git diff --quiet ./test/ || {
    # changes detected
    _error "Test failed!"
    echo $fg[red]
    git diff --stat ./test/
    exit 1
  }
  _echo "TESTING successful!"
  exit 0
fi

# Before proceeding validate storage hierarchy
# This is necessary when dealing with linked subdirectories located on
# separate storage devices like external SSDs or HDDs. When those devices
# are not mounted, links to them still exist but are none operational.
# Depending on processing options, various steps might become impossible.
_validate_storage

if [ "$mount" = true ]; then
  _echo "Mount event received. Option: ${mountopt}"

  # Setup the type of processing that has been configured for a mount event
  _info "Mount options: ${mountoptions}"
  for moption in "${mountoptions[@]}"; do
    _info "Mount option: ${moption}"
    case $moption in 
      --archive)
        archive=true
        ;;
      --import)
        import=true
        ;;
      --clean)
        clean=true
        ;;
      --firmware)
        firmware=true
        ;;
    esac
  done

  # Search for mounted sdcards, start with lifs mount points
  # Cannot rely on USB device mounts, as built in card readers might not be USB

  for mountpoint in $(mount -t lifs | awk '{print $3}'); do # all external filesystems
    _echo "Mountpoint: "$mountpoint 

    # Check if this is a GoPro storage card
    if [[ -f "$mountpoint/MISC/version.txt" ]]; then
      # Create lockfile or skip mountpoint
      if { set -C; : 2>/dev/null >$mountpoint/$DEFAULT_LOCKFILE; }; then
        # Remove lockfile once we exit
         trap "rm -f $mountpoint/$DEFAULT_LOCKFILE" EXIT
      else
         _info "Cannot create $mountpoint/$DEFAULT_LOCKFILE - skipping mountpoint"
         continue
      fi

      # Perform mount processing
      _info "Start mount processing..."

      source=$mountpoint

      # Execute auto tasks configured to run at mount
      if [ "$archive" = true ]; then
        _archive_media
      fi
      if [ "$import" = true ]; then
        _import_media
      fi
      if [ "$clean" = true ]; then
        _clean_media
      fi
      if [ "$firmware" = true ]; then
        _firmware
      fi

      # Done with processing for this mount point remove lock and trap
      rm -f $mountpoint/$DEFAULT_LOCKFILE
      trap - EXIT

      if test -t 0 ; then
        # running interactively - offer to unmount the card - timeout after 30 sec
        if read -t30 -s -q "ANSWER?Do you want to unmount $mountpoint? (sudo required) [y/N] "; then
          echo "Yes"
          _echo "Unmounting ${mountpoint}"
          sudo umount $mountpoint
        else
          echo "No"
        fi
      fi
    else
      _info "Not a GoPro storage card. Skipping..."
    fi
  done

  _echo "Mount processing finished."
  
  exit 0
fi

# Execute in order: archive, import, clean, geonames, process, firmware
if [ "$archive" = true ]; then
  _archive_media
fi
if [ "$import" = true ]; then
  _import_media
fi
if [ "$clean" = true ]; then
  _clean_media
fi
if [ "$geonames" = true ]; then
  _geonames_media
fi
if [ "$timeshift" = true ]; then
  _timeshift_media
fi
if [ "$process" = true ]; then
  _process_media
fi
if [ "$firmware" = true ]; then
  _firmware
fi

if (( $exiftoolstatus )) then
  _warning "exiftool reported one or more errors during this goprox run. Please check output."
fi
_echo "GoProX processing finished."

) 2>&1 | eval ${output}
